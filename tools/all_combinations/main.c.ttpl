// -*- coding: utf-8; mode: c; -*-

#include <stdio.h>
#include <stdbool.h>



typedef struct {
    int x;
    int y;
} struct1_t;

typedef struct {
    int x;
    int y;
    int z;
} struct2_t;

{%
    operations = [
        # ("assign", "{:<30} = {:<30}", 2),

        ("add", "{:<30} + {:<30}", 2),
        ("sub", "{:<30} - {:<30}", 2),
        ("plus", "+ {:<30}", 1),
        ("minus", "- {:<30}", 1),
        ("mul", "{:<30} * {:<30}", 2),
        ("div", "{:<30} / {:<30}", 2),
        ("mod", "{:<30} % {:<30}", 2),
        ("incBefore", "++ {:<30}", 1),
        ("decBefore", "-- {:<30}", 1),
        ("incAfter", "{:<30} ++", 1),
        ("decAfter", "{:<30} --", 1),
        
        ("eq", "{:<30} == {:<30}", 2),
        ("ne", "{:<30} != {:<30}", 2),
        ("gt", "{:<30} > {:<30}", 2),
        ("lt", "{:<30} < {:<30}", 2),
        ("ge", "{:<30} >= {:<30}", 2),
        ("le", "{:<30} <= {:<30}", 2),
        
        ("logicNot", "! {:<30}", 1),
        ("logicAnd", "{:<30} && {:<30}", 2),
        ("logicOr", "{:<30} || {:<30}", 2),

        ("not", "~ {:<30}", 1),
        ("and", "{:<30} & {:<30}", 2),
        ("or", "{:<30} | {:<30}", 2),
        ("xor", "{:<30} ^ {:<30}", 2),
        ("shl", "{:<30} << {:<30}", 2),
        ("shr", "{:<30} >> {:<30}", 2),

        ("addAssign", "{:<30} += {:<30}", 2),
        ("subAssign", "{:<30} -= {:<30}", 2),
        ("mulAssign", "{:<30} *= {:<30}", 2),
        ("divAssign", "{:<30} /= {:<30}", 2),
        ("modAssign", "{:<30} %= {:<30}", 2),
        ("andAssign", "{:<30} &= {:<30}", 2),
        ("orAssign", "{:<30} |= {:<30}", 2),
        ("xorAssign", "{:<30} ^= {:<30}", 2),
        ("shlAssign", "{:<30} <<= {:<30}", 2),
        ("shrAssign", "{:<30} >>= {:<30}", 2),

        ("cast", "(({:<30}) {:<30})", 1),
    ]



    variables = [
        ("bool",                    "b",                "true"),
        ("unsigned char",           "uc",               "'B'"),
        ("signed char",             "sc",               "'C'"),
        ("unsigned short int",      "uSi",              "1"),
        ("signed short int",        "sSi",              "2"),
        ("unsigned int",            "ui",               "3"),
        ("signed int",              "si",               "4"),
        ("unsigned long int",       "uLi",              "5"),
        ("signed long int",         "sLi",              "6"),
        ("unsigned long long int",  "uLLi",             "7"),
        ("signed long long int",    "sLLi",             "8"),
        ("float",                   "f",                "0.1f"),
        ("double",                  "d",                "0.2"),
        ("long double",             "Ld",               "0.3"),
        ("int []",                  "ai",               "{1, 2, 3}"),
        ("double []",               "ad",               "{0.1, 0.2, 0.3}"),
        ("struct1_t",               "struct$si$si",     "{0, 0}"),
        ("struct2_t",               "struct$si$si$si",  "{0, 0, 0}"),
        ("char *",                  "pc",               "NULL"),
        ("short int *",             "pSi",              "NULL"),
        ("int *",                   "pi",               "NULL"),
        ("long int *",              "pLi",              "NULL"),
        ("long long int *",         "pLLi",             "NULL"),
        ("float *",                 "pf",               "NULL"),
        ("double *",                "pd",               "NULL"),
        ("long double *",           "pLd",              "NULL"),
        ("int (*)[]",               "pai",              "NULL"),
        ("double (*)[]",            "pad",              "NULL"),
        ("struct1_t *",             "pstruct$si$si",    "NULL"),
        ("struct2_t *",             "pstruct$si$si$si", "NULL"),
    ]

    import random

    def var_expression(position, name):
        return "{}_{}".format(name, position)

    def var_declaration(type, name, position, value):
        if type.endswith(")[]"):
            return "{} {}_{})[] = {};".format(type[:-3], name, position, value)
        if type.endswith("[]"):
            return "{} {}_{}[] = {};".format(type[:-3], name, position, value)
        return "{} {}_{} = {};".format(type, name, position, value)
%}\

int main(void)
{
\
{% for type, name, value in variables: %}\
{% write(var_declaration(type, name, 0, value)) %}
{% write(var_declaration(type, name, 1, value)) %}
{% write(var_declaration(type, name, 2, value)) %}
{% :end for %}\



{% for op, pattern, size in operations: %}\
{% "/*" %}
{% " * {}".format(op.upper()) %}
{% " */" %}\

{% if size != 1: %}
{% for type1, name1, value1 in variables: %}\
{% for type2, name2, value2 in variables: %}\
{% for typeR, nameR, valueR in variables: %}\
{% "{:<30} = {:<30};".format(var_expression(0, nameR), pattern.format(var_expression(1, name1), var_expression(2, name2))) %}
{% :end for %}\
{% :end for %}\
{% :end for %}\
{% :else: %}
{% for type1, name1, value1 in variables: %}\
{% for typeR, nameR, valueR in variables: %}\
{% if op == "cast": %}\
{% "{:<30} = {:<30};".format(var_expression(0, nameR), pattern.format(typeR, var_expression(1, name1))) %}
{% :else: %}\
{% "{:<30} = {:<30};".format(var_expression(0, nameR), pattern.format(var_expression(1, name1))) %}
{% :end if %}\
{% :end for %}\
{% :end for %}\
{% :end if %}\
\

{% :end for %}\

return 0;
}
